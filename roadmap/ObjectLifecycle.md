# Типы ссылок 
Ссылки на объект бывают трех типов – **strong**, **weak** и **unowned**. 

Объект живет в памяти пока на него есть `хотя бы одна strong ссылка`. 
И если объекты ссылаются перекрестными сильными ссылками, то они никогда не уничтожаются. 
Чтобы этого избежать, нужно одним из объектов сослаться **weak** или **unowned** ссылкой на другой. 
Если в момент обращения к weak переменной на объект уже нет strong ссылок, тогда мы получим **nil**. А при обращении к **unowned** будет выброшено исключение.

# Side table
Это дополнительная область памяти в которой хранится дополнительная информация об объекте. 
Она опциональна, это означает что она не обязательно будет присутствовать у объекта. 
Объекты которые нуждаются в ней - несут некоторые потери в производительности, а те которым она не нужна не испытывают ее “нагрузки”.
    
Вместо того чтобы указывать на сам объект, слабые ссылки теперь указывают на побочную таблицу. 
Так как побочные таблицы занимают немного места — мы избавляемся от проблемы растраты памяти из-за слабых ссылок на большие объекты. 
Это наталкивает на простое решение проблемы потокобезопасности: не обнулять слабые ссылки. 

Так как побочные таблицы малы в размере, мы можем сохранять слабые ссылки на нее пока сами ссылки не будут перезаписаны или уничтожены.
Как только мы начинаем ссылаться на объект слабо `weak reference` - то создается боковая таблица, и теперь объект вместо сильного счетчика ссылок хранит ссылку на боковую таблицу.

Сама боковая таблица также имеет ссылку на объект. Еще боковая таблица может создаваться, когда происходит переполнение счетчика, и он уже не помещается в поле (счетчики ссылок будут маленькими на 32-битных машинах).

С таким механизмом слабые ссылки ссылаются не напрямую на объект, а на боковую таблицу, которая указывает на объект. Это решает две предыдущие проблемы:
  - Экономие памяти: объект удаляется из памяти, если на него больше нет сильных ссылок.
  - Это позволяет безопасно обнулять слабые ссылки, поскольку слабая ссылка теперь не указывает напрямую на объект и не является предметом `race condition.`

# Как устроена side table 
Вот так **side table** выглядит в [исходниках языка](https://github.com/apple/swift/blob/c39901d7fb34debbaf51d225b01f2869cd0b101f/stdlib/public/SwiftShims/RefCount.h#L1310): 
```class HeapObjectSideTableEntry {
  std::atomic<HeapObject*> object;
  SideTableRefCounts refCounts;
}
```
  - В самом первом поле хранится указатель на объект, которому принадлежит эта **side table**. 
  - Следом лежит его счетчик ссылок, представленный структурой типа **SideTableRefCounts**. Внутри нее хранится битовое поле со счетчиками ссылок и флагами.

Side table работает в паре с классом [**WeakReference**](https://github.com/apple/swift/blob/9a5bb49067e21d33c73b32843dcc95f8a88d7a9d/stdlib/public/runtime/WeakReference.h#L156). По сути экземпляр класса WeakReference создается для каждой новой weak переменной. 
И взаимодействие со свойствами и методами объекта происходит через него. Класс WeakReference определен следующим образом:
```
class WeakReference {
  union {
    std::atomic<WeakReferenceBits> nativeValue;
#if SWIFT_OBJC_INTEROP
    id nonnativeValue;
#endif
  };
}
```
  - `nativeValue` сохраняется указатель на нативный объект. Нативным называется объект, структура которого известна рантайму Swift и он может жить без рантайма Objective-C.
  - `nonnativeValue` сохраняется объект, который наследуется от NSObject и им  управляет рантайм Objective-C.

Так как это объединение, то в один момент может хранится только одно значение. Флаг `SWIFT_OBJC_INTEROP` указывает на то, 
нужна ли интероперабельность с Objective-C – то есть можно ли из Swift кода работать с объектами Objective-C. 
На всех платформах от Apple этот флаг активирован. 

# Как работает WeakReference
**WeakReference** хранит указатель на оригинальный объект. 
И для его получения вызывается функция **swift_weakLoadStrong**. 
Она принимает **WeakReference** единственным аргументом и возвращает указатель на **HeapObject**. 
Вызов **swift_weakLoadStrong** также увеличивает на единицу количество strong ссылок. 
Эта дополнительная единица сохраняется до конца текущей области видимости weak переменной. 

В конце области видимости **strong** счетчик уменьшается на единицу. 
А когда объект уже деалоцирован, то вызов **swift_weakLoadStrong** вернет **null**. 
Таким образом, в рантайме реализуется семантика слабых ссылок. 
Ведь экземпляр **HeapObject** физически еще присутствует в памяти. 
А **WeakReference** выступает в роли обертки и проверяет, не уничтожен ли еще объект с точки зрения рантайма. 

# Счетчик ссылок
Счетчик ссылок хранится внутри структуры **HeapObject**. **HeapObject** – это внутреннее представление объекта в рантайме. То есть каждый экземпляр класса в рантайме это экземпляр структуры с типом **HeapObject**.

В алгоритме работы счетчика ссылок определено пять состояний, в которых объект находится на всем пути от создания до удаления из памяти. 
Можно провести параллель с жизненным циклом **UIViewController**. 
Он создается, отображает визуальные элементы, реагирует на вызовы от операционной системы и в конце деаллоцируется. 
Состояния объекта перечислены ниже:

1. `Live` – объект создан и находится в памяти.
2. `Deiniting` – объект находится в процессе деинициализации, то есть у него вызван метод `deinit`.
3. `Deinited` – объект полность деинициализирован.
4. `Freed` – выделенная память под объект освобождена, но `side table` еще существует.
5. `Dead` – память занятая side table освобождается.

![image](https://user-images.githubusercontent.com/47610132/176542135-43d31345-7d44-4197-bafa-96b37afc7e69.png)

  - `Live`, его счетчики инициализируются со значениями strong — 1, unowned — 1, weak — 1 (weak появляется только с боковой таблицей). 
На данный момент нет боковой таблицы. Операции с unowned переменными работают нормально.Когда strong RC достигает нуля, вызывается deinit(), 
и объект переходит в следующее состояние.
  - `Deiniting` - на данном этапе операции со `strong` ссылками не действуют. При чтении через unowned ссылку будет срабатывать assertion failure. 
Но новые unowned ссылки еще могут добавляться. Если есть боковая таблица, то weak операции будут возвращать nil. 
Далее из этого состояния уже можно перейти в два других.
  - Если нет боковой таблицы, то есть нет `weak ссылок` и нет `unowned ссылок`, то объект переходит в `Dead` состояние и сразу удаляется из памяти.
  - Если у нас есть `unowned или weak ссылки`, объект переходит в состояние `Deinited`. 
В этом состоянии функция deinit() завершена, сохранение и чтение сильных или слабых ссылок невозможно. 
Как и сохранение новых `unowned ссылок`. При попытке чтения `unowned ссылки` вызывается assertion failure. Из этого состояния также возможно два исхода.
  - В случае наличия `weak ссылок`, а значит и боковой таблицы, осуществляется переход в состояние `Freed`. 
В `Freed` состоянии объект уже полностью освобожден и не занимает места в памяти, но его боковая таблица остается жива.
  - После того как счетчик слабых ссылок достигает нуля, боковая таблица также удаляется и освобождает память, и осуществляется переход в финальное состояние — `Dead`. 
В этом состоянии от объекта ничего не осталось, кроме указателя на него. Указатель на `HeapObject` освобождается из кучи, не оставляя следов объекта в памяти.

Объект живет пока на него есть **strong** ссылки. И хотя счетчик **strong** ссылок инициализируется нулем, считается, что на объект есть одна ссылка.
Он ссылается сам на себя. Ведь действительно на него еще никто не сослался, но и умирать ему рано.

# Инварианты счетчиков ссылок
Весь жизненный цикл сопровождается инвариантами счетчиков ссылок. 
Инвариантность  —  это выражение, определяющее непротиворечивое внутреннее состояние объекта.

- Если счетчик strong ссылок становится равен нулю, то объект всегда переходит в состояние **deiniting**. `Unowned` ссылки выкидывают ошибку в **runtime**, 
а чтение **weak** ссылок возвращает **nil**.
- Счетчик `unowned` ссылок получает +1 от счетчика strong ссылок, который впоследствие уменьшается после завершения функции `deinit()` объекта.
- Счетчик weak ссылок получает +1 от счетчика `unowned` ссылок. Он уменьшается после освобождения (freed) объекта из памяти.
