`Auto Layout` занимается динамическим вычислением позиции и размера всех view в view иерархии, 
на основе `constraints` — правил заданных для того или иного view. 
Самый большой и очевидный плюс для разработчика в использовании Auto Layout в том, 
что исчезает необходимость в подгонке размеров приложения под определенные устройства — Auto Layout делает это за вас, 
динамически изменяя интерфейс в зависимости от внешних или внутренних изменений.

Внутренний размер содержимого может быть получен через свойства UIView `Intrinsic Content Size`. 
Autolayout учитывает Intrinsic Content Size, создавая для каждого представления внутренние констрейнты для ширины и высоты. 
В отличие от других констрейнтов эти констрейнты имеют два приоритета: **Content Hugging Priority** и **Content Compression Resistance Priority**.

# Для чего нужны **Content Hugging Priority** / **Content Compression Resistance Priority.**

`Content hugging priorities` - устанавливает приоритет, с которым View будет препятствовать увеличению своего размера относительно размеров своего контента. 
Грубо говоря, этот параметр показывает, насколько сильно View не хочет увеличиваться. 
Устанавливая большее значение этому приоритету, мы указываем, что не хотим, чтобы размер View увеличивался больше, чем размер своего контента, и наоборот.

`Content Compression Resistance Priority` - устанавливает приоритет, с которым View будет препятствовать уменьшению своего размера относительно размера 
своего контента, то есть насколько сильно View не хочет уменьшаться. Чем выше значение этого параметра, тем сильнее View препятствует своему сжатию и 
в конечном счете обрезке своего контента.

`Hugging => контент не хочет расти.`
`Compression Resistance => контент не хочет сжиматься`

Например у нас есть кнопка и мы прикрепили края кнопки к большой супервью с приоритетом = 500: `[_____Click Me_____]`

Если `Hugging priority > 500` то кнопка будет выглядить вот так: `[Click Me]`

Если `Hugging priority < 500` то кнопка будет выглядить вот так: `[_____Click Me_____]`

Если супервью сжимается, то `Compression Resistance priority > 500`, и кнопка будет выглядеть так: `[Click Me]`

В противном случае, если `Compression Resistance priority < 500`, кнопка будет выглядеть так: `[Cli..]`

![image](https://user-images.githubusercontent.com/47610132/200193664-582f1c79-b183-4c5e-86ad-68cc9f352b71.png)

# Render loop

1. `updateConstraints` - Позволяет внести изменения для ограничений. Используйте для наилучшего перфоманса, когда нужно `добавить`, `изменить` или `удалить` множество ограничений за один проход `layout'a.`
2. `setNeedsUpdateConstraints` - Вызывает изменения ограничений в следующем цикле рендеринга.
3. `layoutSubviews` - Вы должны переопределить этот метод только в том случае, если автоматическое изменение размера и поведение на основе ограничений вложенных представлений не предлагают желаемого поведения. Вы можете использовать свою реализацию для непосредственной установки прямоугольников фреймов ваших подпредставлений. Вы не должны вызывать этот метод напрямую. Если вы хотите принудительно обновить макет, вызовите метод `setNeedsLayout`, чтобы сделать это до следующего обновления отрисовки. Если вы хотите немедленно обновить лейаут ваших представлений, вызовите метод `layoutIfNeeded`.
4. `setNeedsDisplay` - Вызывает перерисовку вью в следующем цикле рендеринга.

![image](https://user-images.githubusercontent.com/47610132/200196004-619cdc59-7b5a-41b1-90d0-5aac26c7fb18.png)

# Полезные ссылки
- [Математические основы Auto Layout / Антон Сергеев (Яндекс)](https://www.youtube.com/watch?v=-eGciYD9i3I&t=14s)
- [Auto layout magic: content sizing priorities](https://krakendev.io/blog/autolayout-magic-like-harry-potter-but-real)
- [High Performance Auto Layout](https://developer.apple.com/videos/play/wwdc2018/220/)
