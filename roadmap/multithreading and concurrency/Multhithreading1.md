# Многопоточность, введение

Представьте, что у вас есть ресторан. Официант собирает заказы. Кухня готовит еду, бармен варит кофе и коктейли.

В какой-то момент многие люди будут заказывать кофе и еду. На это потребуется много времени, чтобы подготовиться. Внезапно раздается звонок, что нужно в 5 раз больше еды и в 4 раза больше кофе. 
Официанту нужно будет обслуживать столики один за другим, даже если все продукты приготовлены - это `последовательная очередь`. 
С последовательной очередью вы ограничены только одним официантом.

Теперь представьте, что есть **два** или **три официанта**. При этом они могут обслуживать столы намного быстрее - `это параллелизм`. 

`Serial queue` - последовательная очередь.

`Concurrent queue` - параллельная очередь.

![image](https://user-images.githubusercontent.com/47610132/182394517-dba6c74c-48fd-4231-a7e0-e09f1f92dcc6.png)

# Основы многопоточности

- `Main thread / UI Thread`: это поток, который запускается вместе с приложением, 
предварительно определенный последовательный **(serial)** поток. Он слушает взаимодействие с пользователем и изменения пользовательского интерфейса. 
На все изменения немедленно нужна реакция. Будьте осторожны, чтобы не добавлять в эту ветку огромную работу, так как приложение может зависнуть.
> Важно запомнить, что всю отрисовку пользовательского интерфейса мы делаем на `главном потоке!`. Это делается с той точки зрения, что у главного потока
есть гарантированный [Runloop]().

![image](https://user-images.githubusercontent.com/47610132/182425715-7104045c-739a-4c45-8308-1e3bcfdaae80.png)

> Длительная задача в потоке пользовательского интерфейса (неправильно и не следует так делать)

- Background Thread (global): В основном мы создаем задачи в новых потоках исходя из наших потребностей. 
Например, если нам нужно загрузить какое-то изображение большого размера - это делается в фоновом потоке. 
Или любой вызов API. Мы не хотим запрещать пользователям ждать завершения этой задачи. Мы вызовем вызов API для получения списка данных о фильмах в фоновом потоке. 
Когда он прибывает и выполняется синтаксический анализ, мы переключаемся и обновляем пользовательский интерфейс в основном потоке.

`Процесс` - абстракция, описывающая выполняющуюся программу, общаются друг с другом через передачу сообщений.

`Потоки` - мини - процессы внутри процесса, общаются через общую память в процессе.

# Асинхронность vs многопоточность. Чем отличаются?

`Асинхронность` говорит о порядке исполнения кода. Если вызываемая функция не возвращает значение сразу, а отдаёт управление вызывающему коду с обещанием 
выдать значение позже, то эта функция асинхронная. При этом нет никаких предположений о том, как это значение будет считаться: параллельно или нет.

- `Синхронная` операция начинает выполнятся сразу при вызове, блокирует поток. Выполняется в текущем потоке.
- `Асинхронная` операция ставит задачу в очередь выполнения, продолжает выполнение кода, из которого вызвана задача. 
Если очередь однопоточная, то задача будет выполнятся после выполнения всех задач, которые уже поставлены в очередь,
если многопоточная - возможно ее выполнение в другом потоке.

`Многопоточность` - каждый поток имеет свой стек и планируется на исполнение отдельно kernel’ом. Поток может общаться с другими потоками. 
Все потоки находятся в общем адресном пространстве приложения и делят одну и ту же виртуальную память и имеют те же права доступа что и процесс приложения. 
Асинхронные событиямя выполняются независимо от основного потока в неблокирующем режиме, что позволяет основному потоку программы продолжить обработку. 
Т.е результат работы функции приходит не сразу после вызова, а когда-нибудь потом.

# GCD (Grand Central Dispatch)

GCD — это низкоуровневый многопоточный интерфейс от Apple для поддержки параллельного выполнения кода на многоядерном устройстве. 
GCD позволяет вашему девайсу загружать видео в фоновом режиме, сохраняя при этом отзывчивость пользовательского интерфейса.

> DispatchQueue — это объект, который управляет выполнением задач последовательно или параллельно на главном или фоновом потоке. 
Ниже QoS представлены по степени важности, от наиважной и ниже по приоритету.

[Quality of service](https://developer.apple.com/documentation/dispatch/dispatchqos) - приоритет выполнения, применяемый к задачам.
1) `.userInteractive`: Интерактивный пользовательский класс (user interactive) представляет задачи, которые необходимо сделать немедленно. 
Используйте его для обновления пользовательского интерфейса, обработки событий или небольших работ, которые должны быть выполнены с небольшими задержками. 
Общий объем работ, сделанный в этом классе во время выполнения вашего приложения, должен быть небольшим.

2) `.userInitiated`: Инициированный пользовательский класс представляет задачи, которые инициируются из пользовательского интерфейса и могут быть выполнены 
асинхронно. Его нужно использовать, когда пользователь ждет немедленных результатов, и для задач, требующих продолжения взаимодействия с пользователем.

3) `.default`: Дефолтная степень важности.

4) `.utility`: Класс Утилит (utility) представляет длительные по исполнению задачи, как правило, с видимым для пользователя индикатором загрузки. 
Используйте его для вычислений, I/O, при работе с сетями, непрерывных каналов передачи данных и подобных друг другу задач. 
Этот класс является энергоэффективным, к тому же имеет низкое энергопотребление.

5) `.background`: Класс background представляет задачи, о которых пользователь может не знать напрямую. 
Используйте его для предварительной выборки, технического обслуживания и других задач, которые не требуют взаимодействия с пользователем и не 
требовательны ко времени исполнения. Помните, что Apple API-интерфейсы также использует глобальные очереди отправки, так что задачи, 
которые вы добавляете, не будут единственными в этих очередях.

6) `.unspecified`: Представляет собой отсутствие qos и указывает системе на для резерва в будущем.

Всего получается 6 `QoS`ов, из них применимых 5.

# DispatchGroup

Зачастую нам нужно запустить несколько асинхронных процессов, но нам нужно только одно событие, когда все будут завершены. 
Этого можно достичь с помощью DispatchGroup.

> «Группа задач, которые вы отслеживаете как единое целое», — Apple Docs.

Например, иногда вам нужно сделать несколько вызовов API в фоновом потоке. 
Прежде чем приложение будет готово к взаимодействию с пользователем или к обновлению пользовательского интерфейса в основном потоке. Вот код:
```
// 1. Создаем Dispatch Group
let group = DispatchGroup()

// 2.a Task 1
group.enter()
runLongRunningTask1(completion: {
    print("DispatchGroup: Long running Task 1 finished")
    group.leave()
})

// 2.b Task 2
group.enter()
runLongRunningTask2(completion: {
    print("DispatchGroup: Long running Task 2 finished")
    group.leave()
})

// 2.c Task 3
group.enter()
runLongRunningTask3(completion: {
    print("DispatchGroup: Long running Task 3 finished")
    group.leave()
})

// 3. Когда все задачи завершены, уведомляем
let queueType = DispatchQueue.global(qos: .userInitiated)
group.notify(queue: queueType) {
    print("DispatchGroup - notify: All task Finished.")
}
```

- Создаём DispatchGroup
- Затем для этой группы необходимо вызвать событие `group.enter()` для каждой запущенной задачи.
- Для каждой `group.enter()` необходимо также вызывать `group.leave()`, когда задача завершена.
- Когда все пары enter-leave завершены, вызывается `group.notify`.
Если вы заметили, что это делается в фоновом потоке. Вы можете настроить в соответствии с вашими потребностями.

# Semaphore

Семафор позволяет выполнять какой-либо участок кода одновременно только конкретному количеству потоков. 
В основе семафора лежит счетчик, который и определяет, можно ли выполнять участок кода текущему потоку или нет. 
Если счетчик больше нуля — поток выполняет код, в противном случае — нет. В GCD выглядит так:

- `semaphore_create`:   создание семафора (аналог sem_init)
- `semaphore_destroy`: удаление, соответственно (аналог sem_destroy)
- `semaphore_wait`:    блокирующее ожидание на семафоре (аналог sem_wait)
- `semaphore_signal`:   освобождение семафора (аналог sem_post)

```
let semaphore = DispatchSemaphore(value: 1)
DispatchQueue.global().async {
    semaphore.wait()
    sleep(1) // Person 1 playing with Switch
    print("Person 1 - done with Switch")
    semaphore.signal()
}

DispatchQueue.global().async {
    semaphore.wait()
    print("Person 2 - wait finished")
    sleep(1) // Person 2 playing with Switch
    print("Person 2 - done with Switch")
    semaphore.signal()
}
```

# DispatchWorkItem

DispatchWorkItem инкапсулирует работу, которая должна быть выполнена в **dispatch queue** или **dispatch group**. 
DispatchWorkItem, в основном, используется в сценариях, где нам требуется возможность задержки или отмены выполнения блока кода.

> Это позволяет нам отменить поставленную в очередь задачу, однако мы можем `отменить задачу только до того`, как она достигнет начала очереди и начнет выполняться.

- Пример использования:
Представьте, что мы разрабатываем приложение для электронной коммерции, и у нас есть панель поиска, которая показывает результаты с опережением ввода.
Чтобы не отправлять запрос на каждую введенную букву в поисковую панель, мы отправляем только тогда, когда пользователь ничего не печатает в течении 30 миллисекунд.

```
class Controller {
    var workItem: DispatchWorkItem?
    
    func getSearchResult(query: String?) {
        workItem?.cancel()
        
        let networkItem = DispatchWorkItem {
            print("Отправляю запрос на сервер для \(String(describing: query))")
        }
        
        workItem = networkItem
        
        DispatchQueue.global().asyncAfter(
            deadline: .now() + .seconds(2),
            execute: networkItem
        )
    }
}

let controller = Controller()
controller.getSearchResult(query: "Hello")
```

- `Notify` планирует выполнение `work item`  после завершения текущего `work item`.
```
class Controller {
    func getSomeThingFromServer() {
        let networkItem = DispatchWorkItem {
            print("Получаю данные от сервера")
            // Асинхронная задача для получения данных
        }
        
        let notifyTheView = DispatchWorkItem {
            print("Отправляю данные во view элемент")
        }
        
        // Это выполнится когда `networkItem` завершит свою работу
        networkItem.notify(queue: .main) {
            notifyTheView.perform()
        }
        DispatchQueue.global().async(execute: networkItem)
    }
}

let controller = Controller()
controller.getSomeThingFromServer()
```
Это можно использовать для последовательного выполнения двух или более задач, когда первая задача должна быть завершена до выполнения следующей. 
Метод `perform()` для `DispatchWorkItem` запустит выполнение рабочего элемента синхронно в текущем потоке.

- `Wait()` заставляет вызывающую сторону ожидать синхронно, пока `dispatch work item` не завершит выполнение.
```
class Controller {
    func getSomeThingFromServer() {
        let networkItem = DispatchWorkItem {
            print("Получаю данные от сервера")
            print(Thread.current)
        }
        
        DispatchQueue.global().async(execute: networkItem)
        
        // Блокирует текущий поток пока `networkItem` не завершит свою работу
        networkItem.wait()
        
        // Выводит принт, после того как `networkItem` завершит свою работу
        print("Завершил работу")
    }
}

let controller = Controller()
controller.getSomeThingFromServer()

Получаю данные от сервера
<NSThread: 0x600000f5c840>{number = 4, name = (null)}
Завершил работу
```

- `DispatchWorkItemFlags` определяет набор действий для `work item`, как `QoS` и необходимость создания барьера или порождение нового, отдельного, потока. 
Наиболее часто используемые флаги — `assignCurrentContext` и `barrier`.

`barrier` - Заставляет `work item` действовать как барьерный блок при отправке в параллельную очередь. 
В параллельной очереди несколько задач выполняются одновременно в разных потоках.

Когда `work item` с флагом `barrier` начинает выполняться, все задачи в очереди временно приостанавливаются и будут возобновлены после завершения этого рабочего элемента.

`assignCurrentContext` - Задает атрибуты для `work item` в соответствии с атрибутами текущего контекста выполнения.

```
func barrierExample() {
    let concurrentQueue = DispatchQueue(label: "barriers", attributes: .concurrent)
    
    for a in 1...3 {
        concurrentQueue.async {
            print("Асинхронная задача \(a)")
        }
    }
    
    for b in 4...6 {
        concurrentQueue.async(flags: .barrier) {
            print("Барьер номер \(b)")
        }
    }
    
    for c in 7...10 {
        concurrentQueue.async {
            print("Завершение задач \(c)")
        }
    }
}

barrierExample()

Асинхронная задача 1
Асинхронная задача 2
Асинхронная задача 3
Барьер номер 4
Барьер номер 5
Барьер номер 6
Завершение задач 7
Завершение задач 8
Завершение задач 9
Завершение задач 10
```

![image](https://user-images.githubusercontent.com/47610132/184532741-96969f2e-c790-4801-b08d-ccc1466641f0.png)
