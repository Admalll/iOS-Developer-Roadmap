> В POP ключевую роль играют следующие средства языка: protocol, extensions и constraints.

1. `Протокол как тип`
Аналогичен понятию интерфейс из ООП и контракту из контрактного программирования. 
Служит для описания функциональности объекта. 
Может использоваться в качестве типа свойства, в качестве типа результата функции, типа элемента гетерогенной коллекции. 
Из-за ограничений языка, протоколы имеющие associated types или Self-requirements не могут использоваться в качестве типов.

2. `Протокол как шаблон типа`
Аналогичен понятию концепт из обобщённого программирования. 
Так же служит для описания функциональности объекта, но в отличие от «протокол как тип», используется как требование к типу в обобщённых функциях. 
Может содержать associated types. 
Чёткой грани, в каком случае использовать протокол как тип, а в каком — как ограничение на тип, нет, более того — иногда требуется использовать протокол в обоих сценариях. 
Можно попытаться выделить случаи использования:
  - **Классы**, которые предоставляют функциональность для более высоких слоёв приложения и передаются классам-потребителям как зависимости — это сервисы, репозитории, api-клиенты, пользовательские настройки, и прочее.
> В этом случае удобнее использовать протокол как тип — его можно будет зарегистрировать в IOC контейнере, а без его использования — не потребуется в каждой функции, где используется этот сервис, добавлять тип-параметр.
  - **Протокол** с описанием математических операций, например сравнение, сложение, конкатенация и подобные вещи. 
В этом случае удобно воспользоваться Self-requirement (когда в функции или свойстве протокола используется псевдотип Self), 
чтобы избежать опасного приведения и использования разных типов, 
когда операция допускает параметры только одного типа (Int и String в Swift соответствуют протоколу Equatable, но если попытаться проверить их на равенство между собой, компилятор выдаст ошибку, поскольку оператор сравнения требует, чтобы параметры были одного типа). 
Поэтому в этом случае протокол используется как шаблон типа.
  - Иногда требуется сохранить в приватном свойстве протокол имеющий associated types, 
но в этом случае мы не можем использовать протокол как тип.
Есть разные способы решения этой проблемы, например создание аналогичного протокола, в котором использование associated types будет заменено на конкретные типы; использование приёма type erasure — в этом случае associated types переедут в generic параметры типа Any[YourProtocolName].
Ещё варианты — сохранять не сам экземпляр, а его функции. Либо захватить экземпляр в замыкание, которое сохранить в свойство.

3. `Протокол как Trait`
Trait (типаж) — сущность, предоставляющая набор реализованной функциональности. Служит набором строительных блоков для классов/структур/enum-ов.

- Добавление trait не влияет на семантику класса — нет различий между тем, используются методы из traits или методы, определённые прямо в классе. — Верно для протоколов — посмотрев на код, мы не можем определить, где определён метод — в protocol extension или типе, соответствущем протоколу;
- Композиция trait не влияет на семантику trait — составной trait эквивалентен «плоскому» trait, содержащему те же методы. — Использование протокола Foo с методом foo(), который унаследован от протоколов Bar с методом bar() и Baz с методом baz() не отличается от использования протокола, с этими 3 методами: foo(), bar(), baz().

# Правила

1. `«Don't start with a class. Start with a protocol.»`. Это утверждение Dave Abrahams с вышеупомянутой сессии. Можно трактовать 2 способами:
  - начинайте не с реализации, а с описания контракта (описание функциональности, которую объект будет обязан предоставить потребителям)
  - описывайте переиспользуемую логику в протоколах, а не классах. Используйте протокол как единицу переиспользования кода, а класс — как место для уникальной логики. По другому можно описать этот принцип — encapsulate what varies. Хорошим аналогом может стать паттерн «Шаблонный метод». Его идея — отделить общий алгоритм от деталей реализации. Базовый класс содержит общий алгоритм, а дочерние переопределяют определённые шаги алгоритма. В POP общий алгоритм будет содержаться в protocol extension, protocol будет определять шаги алгоритма и используемые типы, а реализация шагов — в классе.
2. `Композиция через расширения`. Многие слышали фразу «предпочитайте композицию наследованию». В ООП, когда от объекта требуется разный набор функциональности (полиморфное поведение), эту функциональность можно либо разбить на части и организовать иерархию классов, где каждый класс наследует функциональность от предка и добавляет свою, либо разбить на несвязанные иерархией классы, экземпляры которых использовать в связующем классе. Используя возможность добавить соответствие протоколу через расширение мы можем использовать композицию не прибегая к созданию вспомогательных классов. Таким способом зачастую пользуются, когда добавляют viewController-у соответствие различным делегатам. Преимущество перед добавлением соответствия протоколам в самом классе — лучше организованный код:

```
extension MyTableViewController: UITableViewDelegate {
    // реализация методов из UITableViewDelegate
}

extension MyTableViewController: UITableViewDataSource {
    // реализация методов из UITableViewDataSource
}

extension MyTableViewController: UITextFieldDelegate {
    // реализация методов из UITextFieldDelegate
}
```

3. `Вместо наследования используйте протоколы`.
Dave Abrahams сравнил протоколы с суперклассами, поскольку они позволяют достичь подобия множественного наследования. 
Если ваш класс содержит много логики, стоит попытаться разбить его на отдельные наборы функциональности, которые вынести в протоколы. 
Разумеется, в случае использования сторонних фреймворков, как Cocoa, наследования не избежать.

4. `Используйте Retroactive modeling.`

Интересный пример с всё той же сессии «Protocol-Oriented Programming in Swift». 
Вместо того, чтобы написать класс реализующий протокол Renderer для отрисовки с помощью CoreGraphics, классу CGContext через extension добавляется соответствие этому протоколу. 
Перед добавлением нового класса, реализующего протокол, стоит задуматься, есть ли тип (класс/структура/enum), который можно адаптировать к соответствию протокола? 
Включайте в протоколы методы, которые можно переопределить (Requirements create customization points).

Если появилась необходимость переопределить общий метод, определённый в protocol extension, для конкретного класса, то перенесите сигнатуру этого метода в protocol requirements.
Другие классы не придётся править, т.к. продолжат использовать метод из расширения. 
Различие будет в формулировке — теперь это «default implementation method» вместо «extension method».

5. `Включайте в протоколы методы, которые можно переопределить (Requirements create customization points).`

Если появилась необходимость переопределить общий метод, определённый в protocol extension, для конкретного класса, то перенесите сигнатуру этого метода в protocol requirements. 
Другие классы не придётся править, т.к. продолжат использовать метод из расширения. 
Различие будет в формулировке — теперь это «default implementation method» вместо «extension method».

# Отличия POP от OOP

**Абстракция**

В ООП роль абстрактного типа данных играет класс. В POP — протокол. Преимущества протокола как абстракции, по утверждению Apple:

- `Поддержка типов значения и классов`
- `Поддержка статичных типов и динамичной диспечеризации`
- `Не монолитный`
- `Поддержка retroactive modeling`
- `Не накладывает данные экземпляра на модели`
- `Не накладывает нагрузку инициализации на модели`
- `Четко указывает, что следует реализовать`

**Инкапсуляция**

Cвойство системы, позволяющее объединить данные и методы, работающие с ними, в классе. 
Протокол не может содержать сами данные, он может содержать только требования на свойства, которые эти данные бы предоставляли. 
Как и в ООП, необходимые данные должны быть включены в класс/структуру, но функции могут быть определены как в классе, так и в `extensions`.

**Полиморфизм**

POP/Swift поддерживает 2 вида полиморфизма:

- `полиморфизм подтипов. Он же используется в ООП:`
    
    ```
    func process(service: ServiceType) { ... }
    ```
    
- `параметрический полиморфизм. Используется в обобщенном программировании.`
    
    ```
    func process<Service: ServiceType>(service: Service) { ... }
    ```
Набор функций принимаемого типа и его associated types определяется по ограничениям. Мы можем не накладывать ограничения, но в этом случае параметр будет аналогичен типу Any:
```
func foo<T>(value: T) { ... }
```
В случае с полиморфизмом подтипов, нам неизвестен конкретный тип, который передаётся в функцию — нахождение реализации методов этого типа будет осуществляться во время выполнения `(Dynamic dispatch)`.
При использовании параметрического полиморфизма — тип параметра известен во время компиляции, соответственно и его методы `(Static dispatch)`.
За счёт того, что на этапе сборки известны используемые типы, компилятор имеет возможность лучше оптимизировать код — в первую очередь, за счёт использования подстановки (inline) функций.

**Наследование**

Наследование в ООП служит для заимствования функциональности от родительского класса. 
В POP получение нужной функциональности происходит за счёт добавления соответствий протоколам, которые предоставляют функции через extensions. 
При этом мы не ограничены классами, имеем возможность расширять за счёт протоколов структуры и enum-ы.

Протоколы могут наследоваться от других протоколов — это означает добавление к собственным требованиям требований от родительских протоколов.

Если выделить `основные особенности` протоколов в Swift, у нас получится следующие 7 пунктов:

- Протоколы не могут хранить состояние
- Протоколы могут быть унаследованы другими протоколами
- Протоколы могут применяться к структурам (struct), классам(class) и перечислениям (enum), определяя функционал типов
- Дженерик протоколы (Generic-protocol) позволяют задавать сложные зависимости между типами и протоколами во время их наследования
- Протоколы не определяют «сильные» и «слабые» ссылки на переменные
- В расширениях к протоколам можно описывать конкретные реализации методов, и вычисляемых переменных (computed values)
- Классовые протоколы разрешают себя наследовать только классам

# Дополнительные материалы:
[WWDC16, Protocol-Oriented Programming in Swift](https://developer.apple.com/videos/play/wwdc2015/408/)
