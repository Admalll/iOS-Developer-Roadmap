# Массивы
`Array` - массив является универсальным контейнером общего назначения для хранения **упорядоченной** коллекции элементов, 
где через него можно выполнить итерацию по крайней мере один раз.

![image](https://user-images.githubusercontent.com/47610132/168491765-bc2d24e5-6ba5-47b6-adae-f7cc1d6b0544.png)

Операции с массивом и их сложность:
  - `O(1) — Константное время(самое быстрое)` Доступ к элементу в массиве по его индексу:
```
let array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

array[3]
```
  - `O(log n) - Логарифмическое время(немного по-хуже, чем константное время)` Сортировка по возрастанию, стандартная функция:
```
var people = ["Sandra", "Mike", "James", "Donald"]
people.sort()
```
  - `O(n) - Линейное время(немного по-хуже, чем логарифмическая сложность)` Подсчёт суммы элементов, при помощи стандартной функции `forEach` или же for i in array:
```
let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
var sumOfNumbers = 0

numbers.forEach {
    sumOfNumbers += $0
}

print(sumOfNumbers) // 55
```
  - `O(n²) - Квадратичное время(немного по-хуже, чем O(n log n)` Прохождение по 2D массиву:
```
var twoDimensionalArray = [["first one", "second one"], ["first two", "second two"], ["first third", "second third"]]

for i in 0..<twoDimensionalArray.count {
    for n in 0..<twoDimensionalArray[i].count {
        print(twoDimensionalArray[i][n])
    }
}
```

# Размерность массива
Каждый массив резервирует определенный объем памяти для хранения его содержимого. 
Когда вы добавляете элементы в массив и этот массив начинает превышать свою зарезервированную емкость, массив выделяет большую область памяти 
и копирует свои элементы в новое хранилище, где новое хранилище кратно размеру старого хранилища.

![image](https://user-images.githubusercontent.com/47610132/168482804-e961d8fe-bf1c-44d6-aca6-b4e37ea8a1a2.png)

Эта экспоненциальная стратегия роста означает, что добавление элемента происходит за постоянное время `O(1)`, усредняя производительность многих операций добавления. 
Операции добавления, запускающие перераспределение, имеют затраты на производительность, но они происходят все реже по мере увеличения массива.

Пример:
Создадим массив с десятью элементами. Swift выделит этому массиву достаточную емкость для хранения только этих десяти элементов,
таким образом и для `array.capacity` и для `array.count` будут равны 10.

```
var array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

print(array.capacity) // 10
print(array.count) // 10
```
Давайте добавим **11** и **12** элементы. Наш массив не имеет для этого емкости, поэтому ему нужно освободить место - он найдет память для хранения большего 
количества элементов, скопирует массив туда, а затем добавит **11** и **12** элементы, где время выполнения этих вставок составляет сложность - `O(n)`, где n - количество элементов в массиве.

```
array.append(11)
array.append(12)

print(array.capacity) // 20
print(array.count) // 12
```

Таким образом, при добавлении 11 и 12 элементов в массив с **емкостью 10**, swift создаст массив с размером **20**. 
И когда мы превысим этот размер, то следующая ёмкость будет 40, потом 80, пото 160 и так далее.

> Если приблизительно известно, сколько элементов необходимо сохранить, используйте метод `reserveCapacity(_:)` перед добавлением в массив, 
чтобы избежать промежуточных перераспределений.
>> Используйте свойства `capacity` и `count`, чтобы определить, сколько элементов массив может хранить без выделения больших ресурсов.

```
var stringArray = Array<String>()
stringArray.reserveCapacity(128)
```

Для массивов с типом Element, который является ссылочным типом, например `класс` или типом протокола `@objc`, 
это место хранения может быть смежным блоком памяти или экземпляром NSArray.
Поскольку любой произвольный подкласс **NSArray** может стать **Array**, в этом случае нет никаких гарантий относительно представления или эффективности в данном кейсе.

Примечание:
`Array<Element>` подобен `ContigingArray <Element>`, если **Element** не является **ссылочным типом** или экзистенциальным **объектом Objective-C**.
В противном случае он может использовать для хранения «NSAray», подключенный от Cocoa.

![image](https://user-images.githubusercontent.com/47610132/168491933-cb4cfbfe-07fd-434d-a292-99fddba40418.png)

`ContiguousArray<T>` хранится «непрерывно», как показано на рисунке выше.

# Изменение копий массивов

# Соединение между Array и NSArray

# Сохранение геометрического роста массива для кастомных элементов

# Дополнительные ресурсы:
 - [Описание сложности алгоритмов в swift](https://github.com/raywenderlich/swift-algorithm-club/blob/master/Big-O%20Notation.markdown)
