
# **Shallow and Deep copy**

- **Shallow copies** - Копирование объектов, таких как объекты коллекции, которые могут содержать другие объекты, также должно выполняться с осторожностью. Как и следовало ожидать, использование оператора = для копирования этих объектов приводит к дублированию ссылки на объект. В случае этих объектов **shallow copies** - означает, что создается новый объект коллекции, но содержимое исходной коллекции не дублируется - в новый контейнер копирует только ссылки на объекты. Этот тип копирования полезен, если, например, у вас есь неизменяемый массив, и вы хотите изменить его порядок. В этом случае вы не хотите дублировать все содержащиеся объекты, потому что их не нужно изменять - а зачем тратить лишнюю память? Вы просто хотите изменить набор включенных объектов. Здесь действуют те же риски, что и при копировании ссылок на объекты с простыми типами. 

![image](https://user-images.githubusercontent.com/47610132/162610680-19cbd8e3-2232-493d-a58b-737265e514da.png)

Пример:
  - human1 - объект типа **Human**, который является классом и тем самым имеет **reference type**.
  - let human2 = human1 — создаётся **shallow copy**
  - Это видно тем, что на изображении объект **human1** и **human2** имеют одинаковый адресс в памяти.

#
- **Deep copy** - если вы хотите создать совершенно новый объект, вы должны выполнить **deep copy**. **Deep copy** дублирует объект, а также содержимое всех содержащихся в нем объектов. Текущий **Core Foundation** включает функцию, которая выполняет глубокое копирование списка свойств(см. CFPropertyListCreateDeepCopy). Если вы хотите создавать глубокие копии других структур, вы можете выполнить глубокое копирование самостоятельно, рекурсивно спускаясь в объект и копируя все его содержимое одно за другим. Позаботьтесь о реализации этой функции, поскольку составные объекты могут быть рекурсивными - они могут прямо или косвенно содержать ссылку на себя - что может вызвать рекурсивный цикл.Т.е:
    - При использовании глубокой копии любой объект, на который указывает источник, копируется, а копия - место назначения. Так будут созданы два совершенно отдельных объекта.
    - Коллекции - глубокая копия коллекции представляет собой две коллекции с дублированием всех элементов исходной коллекции.
    - Менее подвержен **race conditions** и хорошо работает в многопоточном окружении - т.е изменения в одном объекте не окажут влияния на другой объект.
    - **Value type** копируются **deeply**.
    - Создает неглубокую копию, если объект, который назначается, содержит вложенные ссылочные типы.
    - Serializing/De-serializing — создает истинную глубокую копию — use Codable/Archive-Unarchive

![image](https://i.yapx.ru/RnzZy.png)

Пример:
  - Класс **Human** реализует протокол **NSCopying** и имплементирует функцию **copy()**. **human1** - назначается  **human2** с помощью метода copy(). Это создаст глубокую копию  **human1**, а затем назначит эту копию **human2**, то есть будет создан совершенно новый объект.
  - Как видно на рисунке, **human1** и **human2** имеют разный адресс в памяти.

- **Дополнительные материалы**
  - [Apple documentations](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/CopyFunctions.html)
